import fs from "fs/promises";
import path from "path";

//#region src/constants.ts
const DEFAULT_USER_AGENT = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36";
const RE_YOUTUBE = /(?:v=|\/|v\/|embed\/|watch\?.*v=|youtu\.be\/|\/v\/|e\/|watch\?.*vi?=|\/embed\/|\/v\/|vi?\/|watch\?.*vi?=|youtu\.be\/|\/vi?\/|\/e\/)([a-zA-Z0-9_-]{11})/i;
const RE_XML_TRANSCRIPT = /<text start="([^"]*)" dur="([^"]*)">([^<]*)<\/text>/g;

//#endregion
//#region src/errors.ts
var YoutubeTranscriptTooManyRequestError = class extends Error {
	constructor() {
		super("YouTube is receiving too many requests from your IP address. Please try again later or use a proxy. If the issue persists, consider reducing the frequency of requests.");
		this.name = "YoutubeTranscriptTooManyRequestError";
	}
};
var YoutubeTranscriptVideoUnavailableError = class extends Error {
	constructor(videoId) {
		super(`The video with ID "${videoId}" is no longer available or has been removed. Please check the video URL or ID and try again.`);
		this.name = "YoutubeTranscriptVideoUnavailableError";
	}
};
var YoutubeTranscriptDisabledError = class extends Error {
	constructor(videoId) {
		super(`Transcripts are disabled for the video with ID "${videoId}". This may be due to the video owner disabling captions or the video not supporting transcripts.`);
		this.name = "YoutubeTranscriptDisabledError";
	}
};
var YoutubeTranscriptNotAvailableError = class extends Error {
	constructor(videoId) {
		super(`No transcripts are available for the video with ID "${videoId}". This may be because the video does not have captions or the captions are not accessible.`);
		this.name = "YoutubeTranscriptNotAvailableError";
	}
};
var YoutubeTranscriptNotAvailableLanguageError = class extends Error {
	constructor(lang, availableLangs, videoId) {
		super(`No transcripts are available in "${lang}" for the video with ID "${videoId}". Available languages: ${availableLangs.join(", ")}. Please try a different language.`);
		this.name = "YoutubeTranscriptNotAvailableLanguageError";
	}
};
var YoutubeTranscriptInvalidVideoIdError = class extends Error {
	constructor() {
		super("Invalid YouTube video ID or URL. Please provide a valid video ID or URL. Example: \"dQw4w9WgXcQ\" or \"https://www.youtube.com/watch?v=dQw4w9WgXcQ\".");
		this.name = "YoutubeTranscriptInvalidVideoIdError";
	}
};

//#endregion
//#region src/utils.ts
function retrieveVideoId(videoId) {
	if (videoId.length === 11) return videoId;
	const matchId = videoId.match(RE_YOUTUBE);
	if (matchId && matchId.length) return matchId[1];
	throw new YoutubeTranscriptInvalidVideoIdError();
}
async function defaultFetch({ url, lang, userAgent, fetch }) {
	return fetch(url, { headers: {
		...lang && { "Accept-Language": lang },
		"User-Agent": userAgent || DEFAULT_USER_AGENT
	} });
}

//#endregion
//#region src/cache/fs-cache.ts
var FsCache = class {
	cacheDir;
	defaultTTL;
	constructor(cacheDir = "./cache", defaultTTL = 36e5) {
		this.cacheDir = cacheDir;
		this.defaultTTL = defaultTTL;
		fs.mkdir(cacheDir, { recursive: true }).catch(() => {});
	}
	async get(key) {
		const filePath = path.join(this.cacheDir, key);
		try {
			const data = await fs.readFile(filePath, "utf-8");
			const { value, expires } = JSON.parse(data);
			if (expires > Date.now()) return value;
			await fs.unlink(filePath);
		} catch (error) {}
		return null;
	}
	async set(key, value, ttl) {
		const filePath = path.join(this.cacheDir, key);
		const expires = Date.now() + (ttl ?? this.defaultTTL);
		await fs.writeFile(filePath, JSON.stringify({
			value,
			expires
		}), "utf-8");
	}
};

//#endregion
//#region src/cache/in-memory-cache.ts
var InMemoryCache = class {
	cache = new Map();
	defaultTTL;
	constructor(defaultTTL = 36e5) {
		this.defaultTTL = defaultTTL;
	}
	async get(key) {
		const entry = this.cache.get(key);
		if (entry && entry.expires > Date.now()) return entry.value;
		this.cache.delete(key);
		return null;
	}
	async set(key, value, ttl) {
		const expires = Date.now() + (ttl ?? this.defaultTTL);
		this.cache.set(key, {
			value,
			expires
		});
	}
};

//#endregion
//#region src/index.ts
/**
* Implementation notes:
* - Keeps the public surface identical.
* - Internals now use YouTube Innertube `player` to discover captionTracks instead of scraping the watch HTML.
* - Honors `lang`, custom fetch hooks (`videoFetch`, `transcriptFetch`), and optional cache strategy.
*/
var YoutubeTranscript = class YoutubeTranscript {
	fetch;
	constructor(config) {
		this.config = config;
		this.fetch = config?.fetch ?? globalThis.fetch;
	}
	async fetchTranscript(videoId) {
		const identifier = retrieveVideoId(videoId);
		const lang = this.config?.lang;
		const userAgent = this.config?.userAgent ?? DEFAULT_USER_AGENT;
		const cache = this.config?.cache;
		const cacheTTL = this.config?.cacheTTL;
		const cacheKey = `yt:transcript:${identifier}:${lang ?? ""}`;
		if (cache) {
			const cached = await cache.get(cacheKey);
			if (cached) try {
				return JSON.parse(cached);
			} catch {}
		}
		const protocol = this.config?.disableHttps ? "http" : "https";
		const watchUrl = `${protocol}://www.youtube.com/watch?v=${identifier}`;
		const videoPageResponse = this.config?.videoFetch ? await this.config.videoFetch({
			url: watchUrl,
			lang,
			userAgent
		}) : await defaultFetch({
			url: watchUrl,
			lang,
			userAgent,
			fetch: this.fetch
		});
		if (!videoPageResponse.ok) throw new YoutubeTranscriptVideoUnavailableError(identifier);
		const videoPageBody = await videoPageResponse.text();
		if (videoPageBody.includes("class=\"g-recaptcha\"")) throw new YoutubeTranscriptTooManyRequestError();
		const titleMatch = videoPageBody.match(/<title>(.*?)<\/title>/);
		const title = titleMatch ? titleMatch[1] : "";
		const apiKeyMatch = videoPageBody.match(/"INNERTUBE_API_KEY":"([^"]+)"/) || videoPageBody.match(/INNERTUBE_API_KEY\\":\\"([^\\"]+)\\"/);
		if (!apiKeyMatch) throw new YoutubeTranscriptNotAvailableError(identifier);
		const apiKey = apiKeyMatch[1];
		const playerEndpoint = `https://www.youtube.com/youtubei/v1/player?key=${apiKey}`;
		const playerBody = {
			context: { client: {
				clientName: "ANDROID",
				clientVersion: "20.10.38"
			} },
			videoId: identifier
		};
		const playerRes = await this.fetch(playerEndpoint, {
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"User-Agent": userAgent,
				...lang ? { "Accept-Language": lang } : {}
			},
			body: JSON.stringify(playerBody)
		});
		if (!playerRes.ok) throw new YoutubeTranscriptVideoUnavailableError(identifier);
		const playerJson = await playerRes.json();
		const tracklist = playerJson?.captions?.playerCaptionsTracklistRenderer ?? playerJson?.playerCaptionsTracklistRenderer;
		const tracks = tracklist?.captionTracks;
		const isPlayableOk = playerJson?.playabilityStatus?.status === "OK";
		if (!playerJson?.captions || !tracklist) {
			if (isPlayableOk) throw new YoutubeTranscriptDisabledError(identifier);
			throw new YoutubeTranscriptNotAvailableError(identifier);
		}
		if (!Array.isArray(tracks) || tracks.length === 0) throw new YoutubeTranscriptDisabledError(identifier);
		const selectedTrack = lang ? tracks.find((t) => t.languageCode === lang) : tracks[0];
		if (!selectedTrack) {
			const available = tracks.map((t) => t.languageCode).filter(Boolean);
			throw new YoutubeTranscriptNotAvailableLanguageError(lang, available, identifier);
		}
		let transcriptURL = selectedTrack.baseUrl || selectedTrack.url;
		if (!transcriptURL) throw new YoutubeTranscriptNotAvailableError(identifier);
		transcriptURL = transcriptURL.replace(/&fmt=[^&]+$/, "");
		if (this.config?.disableHttps) transcriptURL = transcriptURL.replace(/^https:\/\//, "http://");
		const transcriptResponse = this.config?.transcriptFetch ? await this.config.transcriptFetch({
			url: transcriptURL,
			lang,
			userAgent
		}) : await defaultFetch({
			url: transcriptURL,
			lang,
			userAgent,
			fetch: this.fetch
		});
		if (!transcriptResponse.ok) {
			if (transcriptResponse.status === 429) throw new YoutubeTranscriptTooManyRequestError();
			throw new YoutubeTranscriptNotAvailableError(identifier);
		}
		const transcriptBody = await transcriptResponse.text();
		const results = [...transcriptBody.matchAll(RE_XML_TRANSCRIPT)];
		const segments = results.map((m) => ({
			text: m[3],
			duration: parseFloat(m[2]),
			offset: parseFloat(m[1]),
			lang: lang ?? selectedTrack.languageCode
		}));
		if (segments.length === 0) throw new YoutubeTranscriptNotAvailableError(identifier);
		if (cache) try {
			await cache.set(cacheKey, JSON.stringify({
				title,
				segments
			}), cacheTTL);
		} catch {}
		return {
			title,
			segments
		};
	}
	static async fetchTranscript(videoId, config) {
		const instance = new YoutubeTranscript(config);
		return instance.fetchTranscript(videoId);
	}
};
const fetchTranscript = YoutubeTranscript.fetchTranscript;

//#endregion
export { FsCache, InMemoryCache, YoutubeTranscript, YoutubeTranscriptDisabledError, YoutubeTranscriptInvalidVideoIdError, YoutubeTranscriptNotAvailableError, YoutubeTranscriptNotAvailableLanguageError, YoutubeTranscriptTooManyRequestError, YoutubeTranscriptVideoUnavailableError, fetchTranscript };